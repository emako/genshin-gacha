/**
 * 遍历某个文件夹里的文件的中文字体，生成压缩后的各个类型的字体文件
 * 会将注释也生成打包，因此体积会偏大一点
 */
const glob = require('glob');
const fs = require('fs');
const Fontmin = require('fontmin');
const path = require('path');

const searchPattern = 'src/**/*.@(ts|tsx)'; //搜索文件 glob语法
const outputDir = 'src/font'; // 输出文件位置
const fontData = [
  {
    fontLoc: 'src/resource/HYWenHei-85W.ttf',
    fontFamily: 'HYWenHei-85W',
  },
  {
    fontLoc: 'src/resource/HYWenHei-65W.ttf',
    fontFamily: 'HYWenHei-65W',
  },
];
const defaultText =
  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789,./;\'[]\\`-=<>?:"{}|~!@#$%^&*()_+';

const matchChinese = /[\u4e00-\u9fa5\u3000-\u301e\ufe10-\ufe19\ufe30-\ufe44\ufe50-\ufe6b\uff01-\uffee]/gmu;
const matchChineseChar = /[\u4e00-\u9fa5\u3000-\u301e\ufe10-\ufe19\ufe30-\ufe44\ufe50-\ufe6b\uff01-\uffee]/;
const matchUnicode = /\\u[0-9A-Fa-f]{4}/gmu;
function unicodeToChar(text) {
  return text.replace(/\\u[\dA-F]{4}/gi, function (match) {
    return String.fromCharCode(parseInt(match.replace(/\\u/g, ''), 16));
  });
}
const charObj = Object.create(null);
function walk(char) {
  if (!(char in charObj)) charObj[char] = true;
}
function walkString(str) {
  if (!str) return;
  const unicodes = str.match(matchUnicode);
  const chars = str.match(matchChinese);
  if (unicodes && unicodes.length < 10000) {
    unicodes.forEach((str) => {
      const char = unicodeToChar(str);
      if (char.match(matchChineseChar)) walk(char);
    });
  }
  if (chars) {
    chars.forEach(walk);
  }
}
glob(searchPattern, function (er, files) {
  if (er) throw er;
  console.log(files);
  files.forEach((file) => {
    const data = fs.readFileSync(file, 'utf8');
    walkString(data);
    console.log(`读取${file}完成`);
  });
  const text = Object.keys(charObj).join('') + defaultText;
  const cssData = [];
  Promise.all(
    fontData.map(({ fontLoc, fontFamily }) => {
      return new Promise((resolve, reject) => {
        const fontmin = new Fontmin();
        const { name } = path.parse(fontLoc);
        fontmin.src(fontLoc);
        fontmin.use(
          Fontmin.glyph({
            text,
            hinting: false,
          }),
        );
        fontmin.use(Fontmin.ttf2eot());
        fontmin.use(Fontmin.ttf2woff());
        fontmin.use(Fontmin.ttf2woff2());
        fontmin.use(Fontmin.ttf2svg());
        fontmin.dest(outputDir);
        fontmin.run(function (err, files) {
          if (err) {
            reject(err);
          }
          console.log(`写入字体${name}成功`);
          resolve(`
@font-face {
  font-family: ${fontFamily};
  src: url('./${name}.eot');
  src:
    url('./${name}.eot') format('embedded-opentype'),
    url('./${name}.woff2') format('woff2'),
    url('./${name}.woff') format('woff'),
    url('./${name}.ttf') format('truetype'),
    url('./${name}.svg') format('svg');
  font-weight: normal;
  font-style: normal;
}
`);
        });
      });
    }),
  ).then((values) => {
    fs.writeFileSync(
      path.resolve(outputDir, 'font.css'),
      `
/* generated by srcipts/compressFont.js */
${values.join('\n')}
`,
    );
  });
});
